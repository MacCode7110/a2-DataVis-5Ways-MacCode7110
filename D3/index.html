<!doctype html>
<html lang="en">
  <head>
    <title>CS4804 Assignment 2 - Penguins Data Visualization Using D3</title>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"></link>
  </head>
  <body class = "has-background-danger-light">
    <header>
      <h1 class = "title is-1 is-family-primary has-text-success-dark has-text-weight-bold has-text-centered">Assignment 2 - Penguins Data Visualization Using D3</h1>
    </header>
    <main>
      <section class = "section">
        <div id = "container"></div>
      </section>
    </main>
    <footer class = "footer">
      <div class = "content has-text-centered">
        Created by Matthew McAlarney
      </div>
    </footer>
  </body>
  <script>
    //I am following the guidance of this article to learn how to create a scatter plot in D3.js from csv data and learning/documenting what the related D3 functions do: 
    //https://sabahatiqbal.medium.com/building-a-scatter-plot-with-d3-js-66178fde56ac
    //I also learned about the D3 enter function and its role in completing the mapping of data to SVG elements:
    //https://www.educative.io/answers/what-is-d3-enter-and-exit
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
    //I learned about the D3 csv function: https://www.codecademy.com/resources/docs/d3/selection/csv

    //NOTE: As per the guidance of the TA, I am choosing to kepp the data rows with NA values for the relevant attributes that are part of the scatter plot.

    const container = document.getElementById("container")
    console.log(d3) //test if d3 is loaded

    function loadDataAndGeneratePlot() {
      d3.csv("../penglings.csv", function(dataRow) {
        //Data imputation: Here, I am filtering out all data rows that contain NaN/NA values and species values that are not of type String. Thus, I am only returning the data rows that contain complete data and using those rows to plot points on the scatter plot.
        if (!(dataRow.species instanceof String) && !(isNaN(dataRow.bill_length_mm)) && !(isNaN(dataRow.flipper_length_mm)) && !(isNaN(dataRow.body_mass_g))) {
          return ({
            homeSpecies: dataRow.species,
            billLength: dataRow.bill_length_mm,
            flipperLength: dataRow.flipper_length_mm,
            bodyMass: dataRow.body_mass_g
        })}
      }).then(function(data) {
        console.log(data)

        //Declare the dimensions for the svg container:
        const margin = {top: 15, right: 60, bottom: 60, left: 60}
        const width = 700 - margin.left - margin.right
        const height = 500 - margin.top - margin.bottom

        //Declare the minimum and maximum values shown on each axis:
        const xAxisMinimumValue = 169
        const xAxisMaximumValue = 235
        const yAxisMinimumValue = 2500
        const yAxisMaximumValue = 6500

        //Declare the title of the visualization:
        const title = "Body Mass (g) vs. Flipper Length (mm) Penguins Data Scatter Plot"

        //Add an SVG and g grouping for visualization
        const svg = d3.select("#container")
        .append("svg")
        .attr("width", width + margin.left + margin.right) //Have the width include both horizontal margins to make space for the y-axis label.
        .attr("height", height + margin.top + margin.bottom) //Have the height include both vertical margins to make space for the x-axis label.
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")") //Position the container so that there are still margins at the top and at the left.
        //Above, I am applying margin left and margin top to the visualization, which is made possible by appending the <g> SVG element.
        //The <g> SVG element is a container used to group other SVG elements. Transformations applied to the <g> element are performed on its child elements, and the <g> element's attributes are inherited by its children.

        //Create the x-axis:
        let xScale = d3.scaleLinear().domain([xAxisMinimumValue, xAxisMaximumValue]).range([0, width]) //Smallest, largest passed into range function.
        //The d3 domain function creates a value domain between the specified minimum and maximum values, and the D3 range function maps those values into pixels on the screen.

        //Position the x-axis at the correct location in our svg container and pass x into the axisBottom() function to ensure that the argument axis (x-axis) has tick marks facing outwards (towards the bottom).
        //Note: We need to perform all manipulations on a given axis before rendering it to the screen through the D3 call function.
        let xAxisCreator = d3.axisBottom(xScale)
        xAxisCreator.ticks(7)
        xAxisCreator.tickValues([170, 180, 190, 200, 210, 220, 230])
        xAxisCreator.tickSizeOuter(0)

        svg
        .append("g")
        .attr("transform", "translate(" + 0 + "," + height + ")") //The correct position for the x-axis to begin is at (0, height). The x-axis is included in this grouping through appending g above in this method chaining sequence.
        .call(xAxisCreator) //The call function invokes a callback function on the selection itself. The x-axis is now included in the selection, and the selection is essentially the current grouping that is appended to the svg element.

        //Set a label for the x-axis:
        svg
        .append("text")
        .attr("transform", "translate(" + (width / 2) + "," + (height + (margin.bottom - 20)) + ")")
        .style("text-anchor", "middle") //The text-anchor style is used to align text that is already formatted or wrapped in some way. In this case, we have already translated the text element, and the middle of the text string is aligned at the current x text position.
        .text("Flipper Length (mm)") //Specify the text that appears in the current text element.
        .attr("font-family", "Helvetica Neue, Arial")
        .style('font-size', "15px")

        //Create the y-axis:
        let yScale = d3.scaleLinear().domain([yAxisMinimumValue, yAxisMaximumValue]).range([height, 0]) //Smallest, largest passed into range function.
    
        //Position the y-axis at the correct location in our svg container and pass y into the axisLeft() function to ensure that the argument axis (y-axis) has tick marks facing outwards (towards the left).
        let yAxisCreator = d3.axisLeft(yScale)
        yAxisCreator.ticks(4)
        yAxisCreator.tickValues([3000, 4000, 5000, 6000])
        yAxisCreator.tickSizeOuter(0)
        
        svg.append("g").call(yAxisCreator) //The call function invokes a callback function on the selection itself. The y-axis is now included in the selection, and the selection is essentially the current grouping that is appended to the svg element.

        //Set a label for the y-axis:
        svg
        .append("text")
        .attr("transform", "rotate(270)") //We need to rotate the y-axis label 270 degrees so that the text is aligned vertically and is facing in the correct direction.
        .attr("y", -45) //The x and y attributes are reversed as a result of rotating the text by 270 degrees. 
        .attr("x", (0 - (height / 2)))
        .style("text-anchor", "middle") //Middle of the text string (using y attribute now) is aligned at the current y text position.
        .text("Body Mass (g)")
        .attr("font-family", "Helvetica Neue, Arial")
        .style('font-size', "15px")

        //Append the title to the plot:
        svg
        .append("text")
        .attr("class", "title")
        .attr("y", 20)
        .attr("x", 20)
        .attr("font-family", "Helvetica Neue, Arial")
        .style('font-size', "12px")
        .text(title)

        //Create an ordinal scale to assign colors to different species (a scale consisting of ordinal data - data that is discretely classified and has an order - in this case, the species data is ordinal).
        const colorScale = d3.scaleOrdinal().domain(
          ["Adelie", "Chinstrap", "Gentoo"]).range(
          ["#FF9013", "#9932CC", "#048B8C"]) //When colorScale is used as a function call, a color in the scale range will be returned that corresponds to the specified species type in the domain. 

        //Join the penguins.csv dataset to SVG circles (make it so that there is one circle selected for each row of data in penguins.csv).
        //Also, use the D3 enter function to return an enter selection that represents the elements that need to be appended to the DOM.
        svg.selectAll("circle") //No circles appended to DOM yet.
        .data(data)
        .enter() //return an enter selection for the joined dataset (one circle for each datapoint) that represents the SVG elements that have not been appended to the DOM yet.
        .append("circle") //We append one circle per datapoint that is returned from the data function call chained to the selectAll function call.
        .attr("fill", function (d) {
          return colorScale(d.homeSpecies)
        })
        .attr("cx", function (d) {
          return xScale(parseFloat(d.flipperLength)) //We need to pass in the raw x-coordinate of each data point into the xScale to accurately place the data point on the scatter plot.
        })
        .attr("cy", function (d) {
          return yScale(parseFloat(d.bodyMass)) //We need to pass in the raw y-coordinate of each data point into the yScale to accurately place the data point on the scatter plot.
        })
        .attr("r", function (d) {
          return parseFloat(d.billLength) / 6.0 //Play around with the value of the denominator.
        })
        .style("opacity", 0.8) //Set the opacity of each circle to 0.8.
        }).catch(function(error) {
          console.error(error)
        })
    }

    loadDataAndGeneratePlot()
  </script>
</html>